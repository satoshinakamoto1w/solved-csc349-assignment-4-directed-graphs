Download Link: https://assignmentchef.com/product/solved-csc349-assignment-4-directed-graphs
<br>
In a directed graph, the existence of a path from a vertex <em><sub>u </sub></em>to a vertex <em><sub>v </sub></em>does not imply the existence of a path from <em><sub>v </sub></em>back to <em><sub>u</sub></em>. As a result, finding a path from <em><sub>u </sub></em>to <em><sub>v </sub></em>does not necessarily mean that they are in the same component. Finding the components of a directed graph requires a more sophisticated approach than a pure depth-first search.

<strong>Deliverables:</strong>

<strong>GitHub Classroom: </strong><a href="https://classroom.github.com/a/xR_lUIYN">https://classroom.github.com/a/xR_lUIYN</a>

<strong>Required Files:                   </strong>compile.sh, run.sh

<strong>Optional Files:                           </strong>*.py, *.java, *.clj, *.kt, *.js, *.sh

<h1>Part 1: Strongly Connected Components</h1>

Recall that a <em>strongly connected component </em>of a directed graph is a set of vertices within which there exists a

directed path between every pair of vertices. For example, consider the following directed graph:

This graph contains three strongly connected components: {<em><sub>v</sub></em><sub>1</sub><em><sub>,v</sub></em><sub>2</sub><em><sub>,v</sub></em><sub>3</sub>}, {<em><sub>v</sub></em><sub>0</sub><em><sub>,v</sub></em><sub>4</sub>}, and {<em><sub>v</sub></em><sub>5</sub>}. Further recall that such components are <em>maximal</em>, in that no more vertices may be added to a component without breaking its strong connectedness. Thus, <em><sub>v</sub></em><sub>0 </sub>alone does not form a component, because <em><sub>v</sub></em><sub>4 </sub>can still be added. In your programming language of choice per Assignment 1, implement an algorithm to find the strongly connected components of a directed graph. To help you get started, note the following observations:

<ul>

 <li>No strongly connected component can span multiple trees in a forest generated by a depth-first search.</li>

 <li>Assigning pre- and postvisit numbers to vertices during a depth-first</li>

</ul>

search allows identification of back edges.                                                                     2<em><sub>,</sub></em><sub>7</sub>

<ul>

 <li>Finding a back edge during a depth-first search indicates the existence <em><sup>v</sup></em><sup>3 </sup>of a cycle.</li>

 <li>All vertices along a cycle must be in the same strongly connected <sub>3<em>,</em>6</sub></li>

</ul>

component.                                                                                                                                  <em>v</em><sub>1</sub>

<ul>

 <li>If two cycles share any vertices, then they are both in the same strongly</li>

</ul>

connected component.                                                                                                        <sub>4<em>,</em>5</sub>

<em>v</em><sub>5</sub>

Each input graph will be provided as an <em>edge list</em>: each edge in the graph will be represented by a commaseparated pair of vertex identifiers, indicating an edge from the first vertex to the second.

You may assume that vertex identifiers are contiguous natural numbers — they begin at <sub>0</sub>, and there will be no “gaps” in the identifiers used. You may also assume that the graph will be simple and will not contain any isolated vertices.

For example, the above graph could be represented as:

0, <a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a>0, 3 2, 3 0, 4 1, 5 4, 3

3, 1

1, 2

4, 0

Your program must accept as a command line argument the name of a file containing an edge list as described above, then print to stdout the strongly connected components according to the following format:

<ul>

 <li>Vertices within the same component appear on a single comma-separated line. Vertices in different components appear on different lines.</li>

 <li>Each line’s vertices must be sorted in ascending order. Note that vertex identifiers are integers, not strings. The lines themselves must be sorted in ascending order using their smallest vertex identifiers. For example:</li>

</ul>

&gt;$ ./compile.sh

&gt;$ ./run.sh in1.txt

3 Strongly Connected Component(s):

0, 4

1, 2, 3

5

Your program will be tested using diff, so its printed output must match <em>exactly</em>.

<a href="#_ftnref1" name="_ftn1">[1]</a> of 3